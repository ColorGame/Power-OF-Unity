//#define HEX_GRID_SYSTEM //ШЕСТИГРАННАЯ СЕТОЧНАЯ СИСТЕМА //  В C# определен ряд директив препроцессора, оказывающих влияние на интерпреpublic enumтацию исходного кода программы компилятором. 
//Эти директивы определяют порядок интерпретации текста программы перед ее трансляцией в объектный код в том исходном файле, где они появляются. 

using Pathfinding;
using System;
using System.Collections.Generic;
using UnityEngine;
using static UnitActionSystem;


// Добавим LevelGridVisual для запуска после времени по умолчанию, поскольку мы хотим, чтобы визуальные эффекты запускались после всего остального.
// (Project Settings/ Script Execution Order и поместим выполнение LevelGridVisual НИЖЕ Default Time)
public class LevelGridVisual : MonoBehaviour //Сеточная система визуализации  Визуализация возможных ходов по сетке 
{
    [Serializable] // Чтобы созданная структура могла отображаться в инспекторе
    public struct GridVisualTypeMaterial    //Визуал сетки Тип Материала // Создадим структуру можно в отдельном классе. Наряду с классами структуры представляют еще один способ создания собственных типов данных в C#
    {                                       //В данной структуре объединям состояние сетки с материалом
        public GridVisualType gridVisualType;
        public Material materialGrid;
    }

    public enum GridVisualType //Визуальные состояния сетки
    {
        White,
        Blue,
        BlueSoft,
        Red,
        RedSoft,
        Yellow,
        YellowSoft,
        Green,
        GreenSoft,
    }


    [SerializeField] private List<GridVisualTypeMaterial> _gridVisualTypeMaterialListQuad; // Список тип материала визуального состояния сетки Квадрат (Список из кастомного типа данных) визуального состояния сетки // В инспекторе под каждое состояние перетащить соответствующий материал сетки
    [SerializeField] private List<GridVisualTypeMaterial> _gridVisualTypeMaterialListHex; // Список тип материала визуального состояния сетки Шестиугльник (Список из кастомного типа данных) визуального состояния сетки // В инспекторе под каждое состояние перетащить соответствующий материал сетки


    private List<GridPositionXZ> _validGridPositionForGrenadeActionList; // Будем кэшировоть -Список Допустимых сеточных позиций для действия Гранаты 
    private List<GridPositionXZ> _validGridPositionForComboActionList; // Будем кэшировоть -Список Допустимых сеточных позиций для действия комбо

    private LevelGridVisualSingle[,,] _gridSystemVisualSingleArray; // Трехмерный массив    

    private UnitActionSystem _unitActionSystem;
    private LevelGrid _levelGrid;
    private MouseOnGameGrid _mouseOnGameGrid;

    // Для отладки шестигранной сетки (отображение ячейки под мышкой)
    // private LevelGridVisualSingle _lastSelectedGridSystemVisualSingle; // Последний Выбранная Сеточная Позиция Визуализация Еденицы

    public void Init(UnitActionSystem unitActionSystem, LevelGrid levelGrid, MouseOnGameGrid mouseOnGameGrid)
    {
        _unitActionSystem = unitActionSystem;
        _levelGrid = levelGrid;
        _mouseOnGameGrid = mouseOnGameGrid;
    }

    private void Start()
    {
        _gridSystemVisualSingleArray = new LevelGridVisualSingle[ // создаем массив определенного размером _widthX на _heightY  и FloorAmount
            _levelGrid.GetWidth(),
            _levelGrid.GetHeight(),
            _levelGrid.GetFloorAmount()
        ];

        for (int x = 0; x < _levelGrid.GetWidth(); x++)
        {
            for (int z = 0; z < _levelGrid.GetHeight(); z++)
            {
                for (int floor = 0; floor < _levelGrid.GetFloorAmount(); floor++)  // переберем все этажи
                {
                    GridPositionXZ gridPosition = new GridPositionXZ(x, z, floor);

                    Transform gridSystemVisualSingleTransform = Instantiate(GameAssets.Instance.levelGridSystemVisualSinglePrefab, _levelGrid.GetWorldPosition(gridPosition), Quaternion.identity); // Создадим наш префаб в каждой позиции сетки

                    _gridSystemVisualSingleArray[x, z, floor] = gridSystemVisualSingleTransform.GetComponent<LevelGridVisualSingle>(); // Сохраняем компонент LevelGridVisualSingle в трехмерный массив где x,y,_floor это будут индексы массива.
                }
            }
        }

        _unitActionSystem.OnSelectedActionChanged += UnitActionSystem_OnSelectedActionChanged; // подпишемся на событие Выбранное Действие Изменено (когда меняется активное действие в блоке кнопок мы запустим событие Event)
        _unitActionSystem.OnBusyChanged += Instance_OnBusyChanged; //подпишемся на событие Занятость Изменена 
        _mouseOnGameGrid.OnMouseGridPositionChanged += MouseOnGameGrid_OnMouseGridPositionChanged;// подпишемся на событие Сеточная Позиция Мыши Изменена для включения и выключения круга показ. диапазон поражения гранаты
        MoveAction.OnAnyUnitPathComplete += MoveAction_OnAnyUnitPathComplete; //подпишемся У любого Юнита Вычислен Путь       

        UpdateGridVisual();


        // Отабразим всю сетку для отладки HEX(ЗАКОМЕНТИРОВАЛ СТРОКУ в методе MouseOnGameGrid_OnMouseGridPositionChanged)
        /* for (int x = 0; x < _levelGrid.GetWidth(); x++)
         {
             for (int y = 0; y < _levelGrid.GetHeight(); y++)
             {
                 _gridSystemVisualSingleArray[x, y].
                     ShowTooltipsFollowMouse(GetGridVisualTypeMaterial(GridVisualType.White));
             }
         }*/

    }

    private void MoveAction_OnAnyUnitPathComplete(object sender, Unit unit)
    {
        if (_unitActionSystem.GetSelectedUnit() == unit) // Если путь вычислен у выделенного юнита то обновим визуализацию (чтобы не обновлять во время хотьбы врагов)
        {
            UpdateGridVisual();
        }
    }
    private void Instance_OnBusyChanged(object sender, OnUnitSystemEventArgs e)
    {
        if (e.selectedAction is not MoveAction) // Если Занятость Изменена НЕ во время движения то обновим. MoveAction сам подписан на OnBusyChanged и в нем расчитывает путь.
                                                // После расчета вызывается событие OnAnyUnitPathComplete там и будем обновлять
        {
            UpdateGridVisual();
        }
    }
    private void UnitActionSystem_OnSelectedActionChanged(object sender, EventArgs e)
    {
        UpdateGridVisual();
    }



    private void MouseOnGameGrid_OnMouseGridPositionChanged(object sender, MouseOnGameGrid.OnMouseGridPositionChangedEventArgs e)
    {
        // При изминении положении мыши будем обновлять отображение круга или квадрата, который показывает радиус действия гранаты

        BaseAction selectedAction = _unitActionSystem.GetSelectedAction(); // Получим Выбранное Действие

        switch (selectedAction) // Переключатель состояний визуала в зависимости от Выбранного Действия
        {
            case GrenadeFragmentationAction grenadeFragmentationAction:// Во время кидания ГРАНАТЫ

                UpdateVisualDamageCircleGrenade(grenadeFragmentationAction, e);
                break;

            case GrenadeStunAction grenadeStunAction:// Во время кидания ГРАНАТЫ

                UpdateVisualDamageCircleGrenade(grenadeStunAction, e);
                break;

            case GrenadeSmokeAction grenadeSmokeAction:

                UpdateVisualDamageQuadGrenade(grenadeSmokeAction, e);
                break;

            case GrappleAction comboAction:
                if (comboAction.GetState() == GrappleAction.State.ComboStart)
                {
                    UpdateVisualSelectedQuadComboAction(comboAction, e);
                }
                break;
        }
    }

    private void UpdateVisualSelectedQuadComboAction(GrappleAction comboAction, MouseOnGameGrid.OnMouseGridPositionChangedEventArgs e)
    {
        _gridSystemVisualSingleArray[e.lastMouseGridPosition.x, e.lastMouseGridPosition.z, e.lastMouseGridPosition.floor].HideQuadGrenade(); // Скроем квадрат на предыдущей ячейки
        GridPositionXZ mouseGridPosition = e.newMouseGridPosition; // Сеточная позиция мыши

        if (_validGridPositionForComboActionList.Contains(mouseGridPosition)) // Если Сеточная позиция мыши входит в Допустимый диапазон то ...
        {
            _gridSystemVisualSingleArray[mouseGridPosition.x, mouseGridPosition.z, mouseGridPosition.floor].ShowQuadGrenade(GetGridVisualTypeMaterial(GridVisualType.Red)); // Покажем для нашей сеточной позиции квадрат красного цвета (куда надо переместить захваченного врага)
        }
    }

    private void UpdateVisualDamageQuadGrenade(GrenadeAction grenadeAction, MouseOnGameGrid.OnMouseGridPositionChangedEventArgs e)
    {
        _gridSystemVisualSingleArray[e.lastMouseGridPosition.x, e.lastMouseGridPosition.z, e.lastMouseGridPosition.floor].HideQuadGrenade(); // Скроем квадрат на предыдущей ячейки
        GridPositionXZ mouseGridPosition = e.newMouseGridPosition; // Сеточная позиция мыши

        if (_validGridPositionForGrenadeActionList.Contains(mouseGridPosition)) // Если Сеточная позиция мыши входит в Допустимый диапазон то ...
        {
            float damageRadiusInWorldPosition = grenadeAction.GetDamageRadiusInWorldPosition();
            _gridSystemVisualSingleArray[mouseGridPosition.x, mouseGridPosition.z, mouseGridPosition.floor].ShowQuadGrenade(GetGridVisualTypeMaterial(GridVisualType.RedSoft), damageRadiusInWorldPosition); // Покажем для нашей сеточной позиции квадрат поражения от гранаты и передадим размер  и цвет материала
        }
    }

    private void UpdateVisualDamageCircleGrenade(GrenadeAction grenadeAction, MouseOnGameGrid.OnMouseGridPositionChangedEventArgs e)
    {
        _gridSystemVisualSingleArray[e.lastMouseGridPosition.x, e.lastMouseGridPosition.z, e.lastMouseGridPosition.floor].HideСircleGrenade(); // Скроем круг на предыдущей ячейки
        GridPositionXZ mouseGridPosition = e.newMouseGridPosition; // Сеточная позиция мыши

        if (_validGridPositionForGrenadeActionList.Contains(mouseGridPosition)) // Если Сеточная позиция мыши входит в Допустимый диапазон то ...
        {
            float damageRadiusInWorldPosition = grenadeAction.GetDamageRadiusInWorldPosition();
            _gridSystemVisualSingleArray[mouseGridPosition.x, mouseGridPosition.z, mouseGridPosition.floor].ShowСircleGrenade(damageRadiusInWorldPosition); // Покажем для нашей сеточной позиции круг поражения от гранаты и передадим радиус круга
        }
    }

    private void HideAllGridPosition() // Скрыть все позиции сетки
    {
        for (int x = 0; x < _levelGrid.GetWidth(); x++)
        {
            for (int z = 0; z < _levelGrid.GetHeight(); z++)
            {
                for (int floor = 0; floor < _levelGrid.GetFloorAmount(); floor++)  // переберем все этажи
                {
                    _gridSystemVisualSingleArray[x, z, floor].Hide();
                }
            }
        }
    }

    private void ShowGridPositionRange(GridPositionXZ gridPosition, int range, GridVisualType gridVisualType, bool showFigureRhombus) // Показать возможный Диапазон Сеточных Позиций для стрельбы (в аргументе передаем Сеточную позицию, Радиус стрельбы, Тип состояния Визуала Сетки, Булевая переменная если надо отобразить в виде Ромба то передаем true, если в виде КВАДРАТА то - false )
    {
        // По аналогии как в ShootAction в методе "public override List<GridPositionXZ> GetValidActionGridPositionList()"

        List<GridPositionXZ> gridPositionList = new List<GridPositionXZ>();

        for (int x = -range; x <= range; x++)  // Юнит это центр нашей позиции с координатами unitGridPosition, поэтому переберем допустимые значения в условном радиусе range
        {
            for (int z = -range; z <= range; z++)
            {
                GridPositionXZ offsetGridPosition = new GridPositionXZ(x, z, 0); // Смещенная сеточная позиция. Где началом координат(0,0) является сам юнит 
                GridPositionXZ testGridPosition = gridPosition + offsetGridPosition; // Тестируемая Сеточная позиция

                if (!_levelGrid.IsValidGridPosition(testGridPosition)) // Проверим Является ли testGridPosition Допустимой Сеточной Позицией если нет то переходим к след циклу
                {
                    continue; // continue заставляет программу переходить к следующей итерации цикла 'for' игнорируя код ниже
                }

                LevelGridNode levelGridNode = _levelGrid.GetGridNode(testGridPosition);

                //если в этой позиции нет узла пути значит эта GridPositionXZ висит в воздухе  
                if (levelGridNode == null)
                {
                    continue; // Пропустим эту позицию
                }


                /*//Исключим сеточные позиции которые висят в воздухе
                if (PathfindingMonkey.Instance.GetGridPositionInAirList().Contains(testGridPosition))
                {
                    continue;
                }*/

                if (showFigureRhombus)
                {
                    // Для диапазона действия сделаем ромб а не квадрат
                    int testDistance = Mathf.Abs(x) + Mathf.Abs(z); // Сумма двух положительных координат сеточной позиции
                    if (testDistance > range) //Получим фигуру из ячеек в виде ромба // Если юнит в (0,0) то ячейка с координатами (5,4) уже не пройдет проверку 5+4>7
                    {
                        continue;
                    }
                }
                gridPositionList.Add(testGridPosition);
            }
        }

        ShowGridPositionList(gridPositionList, gridVisualType); // Покажем возможный Диапазон стрельбы
    }

    public void ShowGridPositionList(List<GridPositionXZ> gridPositionlist, GridVisualType gridVisualType)  //Покажем Список GridPositionXZ (в аргументе передается список GridPositionXZ и состояние визуализации сетки gridVisualType)
    {
        foreach (GridPositionXZ gridPosition in gridPositionlist) // в цикле перебереи список и Покажем(включим) только те позиции которые нам передали
        {
            _gridSystemVisualSingleArray[gridPosition.x, gridPosition.z, gridPosition.floor].
                Show(GetGridVisualTypeMaterial(gridVisualType)); // В аргумент ShowTooltipsFollowMouse предадим материал в зависимости от переданного нам события
        }
    }

    public void UpdateGridVisual() // Обнавление визуала сетки
    {
        HideAllGridPosition(); // Скрыть все позиции сетки

        Unit selectedUnit = _unitActionSystem.GetSelectedUnit(); //Получим Выбранного Юнита

        BaseAction selectedAction = _unitActionSystem.GetSelectedAction(); // Получим Выбранное Действие

        GridVisualType gridVisualType;  // Создадим перем типа GridVisualType

        switch (selectedAction) // Переключатель состояний визуала сетки в зависимости от Выбранного Действия
        {
            default: // Этот кейс будет выполняться по умолчанию если нет соответствующих selectedAction
            case MoveAction moveAction: // Во время ХОТЬБЫ -БЕЛЫЙ
                gridVisualType = GridVisualType.White;
                break;

            case VisionAction spinAction: // Во время ПОВОРОТА -ГОЛУБОЙ
                gridVisualType = GridVisualType.Blue;
                break;

            case HealAction healAction: // Во время ЛЕЧЕНИЯ -ЗЕЛЕНЫЙ
                gridVisualType = GridVisualType.Green;
                ShowGridPositionRange(selectedUnit.GetGridPosition(), healAction.GetMaxActionDistance(), GridVisualType.GreenSoft, false); // Покажем диапазон 
                break;

            case ShootAction shootAction: // Во время СТРЕЛЬБЫ -КРАСНЫЙ
                gridVisualType = GridVisualType.Red;
                ShowGridPositionRange(selectedUnit.GetGridPosition(), shootAction.GetMaxActionDistance(), GridVisualType.RedSoft, true); // Покажем диапазон стрельбы РОМБ-true
                break;

            case GrenadeAction grenadeAction:// Во время кидания ГРАНАТЫ -ЖЕЛТЫЙ
                gridVisualType = GridVisualType.Yellow;
                _validGridPositionForGrenadeActionList = grenadeAction.GetValidActionGridPositionList(); //Сохраним -Список Допустимых сеточных позиций для действия Гранаты                                 
                break;

            case SwordAction swordAction: // Во время удара МЕЧОМ -красный
                gridVisualType = GridVisualType.Red;
                ShowGridPositionRange(selectedUnit.GetGridPosition(), swordAction.GetMaxActionDistance(), GridVisualType.RedSoft, false); // Покажем диапазон удара
                break;

            case InteractAction interactAction: // Во время ВЗАИМОДЕЙСТВИЯ -ГОЛУБОЙ
                gridVisualType = GridVisualType.Blue;
                ShowGridPositionRange(selectedUnit.GetGridPosition(), interactAction.GetMaxActionDistance(), GridVisualType.BlueSoft, false); // Покажем диапазон 
                break;

            case GrappleAction comboAction: // Во время Выбора комбо союзника -ЗЕЛЕНЫЙ    

                GrappleAction.State statecomboAction = comboAction.GetState(); // Получим состояние КОМБО 
                switch (statecomboAction)
                {
                    default:
                    case GrappleAction.State.ComboSearchPartner: // Если ищем Партнера для комбо
                        gridVisualType = GridVisualType.Green;
                        ShowGridPositionRange(selectedUnit.GetGridPosition(), comboAction.GetMaxActionDistance(), GridVisualType.GreenSoft, false); // Покажем диапазон 
                        break;

                    case GrappleAction.State.ComboSearchEnemy: // Если Ищем врага то
                        gridVisualType = GridVisualType.Red;
                        ShowGridPositionRange(selectedUnit.GetGridPosition(), comboAction.GetMaxActionDistance(), GridVisualType.RedSoft, true); // Покажем диапазон  РОМБ-true
                        break;

                    case GrappleAction.State.ComboStart: // Ячейки куда надо перетащить
                        gridVisualType = GridVisualType.RedSoft;
                        _validGridPositionForComboActionList = selectedAction.GetValidActionGridPositionList();
                        break;

                }
                break;

            case SpotterFireAction spotterFireAction: // Корректировка огня -ЗЕЛЕННЫЙЙ
                gridVisualType = GridVisualType.Green;
                ShowGridPositionRange(selectedUnit.GetGridPosition(), spotterFireAction.GetMaxActionDistance(), GridVisualType.GreenSoft, false); // Покажем диапазон 
                break;
        }

        ShowGridPositionList(selectedAction.GetValidActionGridPositionList(), gridVisualType); // Покажем(включим) только те позиции которые нам передали (в аргумент передаем список допустимых позиций сетки выбранного действия, и Тип состояния визуализации который нам выдал switch)
    }



#if HEX_GRID_SYSTEM // Если ШЕСТИГРАННАЯ СЕТОЧНАЯ СИСТЕМА

    private Material GetGridVisualTypeMaterial(GridVisualType gridVisualType) //(Вернуть Материал в зависимости от Состояния) Получить Тип Материала для Сеточной Визуализации в зависимости от переданного в аргумент Состояния Сеточной Визуализации
    {
        foreach (GridVisualTypeMaterial gridVisualTypeMaterial in _gridVisualTypeMaterialListHex) // в цикле переберем Список тип материала визуального состояния сетки 
        {
            if (gridVisualTypeMaterial.gridVisualType == gridVisualType) // Если  Состояние сетки(gridVisualType) совподает с переданным нам состояние то ..
            {
                return gridVisualTypeMaterial.materialGrid; // Вернем материал соответствующий данному состоянию сетки
            }
        }

        Debug.LogError("Не смог найти GridVisualTypeMaterial для GridVisualType " + gridVisualType); // Если не найдет соответсвий выдаст ошибку
        return null;
    }


#else//в противном случае компилировать

    private Material GetGridVisualTypeMaterial(GridVisualType gridVisualType) //(Вернуть Материал в зависимости от Состояния) Получить Тип Материала для Сеточной Визуализации в зависимости от переданного в аргумент Состояния Сеточной Визуализации
    {
        foreach (GridVisualTypeMaterial gridVisualTypeMaterial in _gridVisualTypeMaterialListQuad) // в цикле переберем Список тип материала визуального состояния сетки 
        {
            if (gridVisualTypeMaterial.gridVisualType == gridVisualType) // Если  Состояние сетки(gridVisualType) совподает с переданным нам состояние то ..
            {
                return gridVisualTypeMaterial.materialGrid; // Вернем материал соответствующий данному состоянию сетки
            }
        }

        Debug.LogError("Не смог найти GridVisualTypeMaterial для GridVisualType " + gridVisualType); // Если не найдет соответсвий выдаст ошибку
        return null;
    }
#endif
}
