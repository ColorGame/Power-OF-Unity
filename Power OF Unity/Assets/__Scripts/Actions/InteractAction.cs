using System;
using System.Collections.Generic;
using UnityEngine;

public class InteractAction : BaseAction // Действие взаимодействия
{
    public static event EventHandler OnAnyInteractActionComplete; // Любое взаимодействие завершено

    private int _maxInteractDistance = 1; // Дистанция взаимодействия
    private GridPositionXZ _targetGridPosition;

    private void Update()
    {
        if (!_isActive) // Если не активны то ...
        {
            return; // выходим и игнорируем код ниже
        }

        Vector3 targetDirection = (_unit.GetLevelGrid().GetWorldPosition(_targetGridPosition) - transform.position).normalized; // Направление к целивой позиции, еденичный вектор
        float rotateSpeed = 10f; //НУЖНО НАСТРОИТЬ//

        transform.forward = Vector3.Slerp(transform.forward, targetDirection, Time.deltaTime * rotateSpeed); // поворт юнита.

        //Что бы мы не смогли открывать и тутже закрывать дверь не дождавшись окончания действия - полного открытия или закрытия
        //Будем вызывать данную функцию через делегат на самой ДВЕРИ когда на ней закончиться таймер
        //ActionComplete(); //Действие завершено

    }

    public override string GetActionName() // Получим имя для кнопки
    {
        return "взаимодействие";
    }

    public override EnemyAIAction GetEnemyAIAction(GridPositionXZ gridPosition) //Получить действие вражеского ИИ  для переданной нам сеточной позиции// Переопределим абстрактный базовый метод //EnemyAIAction создан в каждой Допустимой Сеточнй Позиции, наша задача - настроить каждую ячейку в зависимости от состоянии юнита который там стоит
    {
        return new EnemyAIAction
        {
            gridPosition = gridPosition,
            actionValue = 0
        };
    }

    public override List<GridPositionXZ> GetValidActionGridPositionList() // Получить Список Допустимых Сеточных Позиция для Действий // переопределим базовую функцию  
    {
        List<GridPositionXZ> validGridPositionList = new List<GridPositionXZ>();

        GridPositionXZ unitGridPosition = _unit.GetGridPosition(); // Получим позицию в сетке юнита

        for (int x = -_maxInteractDistance; x <= _maxInteractDistance; x++) // Юнит это центр нашей позиции с координатами unitGridPosition, поэтому переберем допустимые значения в условном радиусе _maxInteractDistance
        {
            for (int z = -_maxInteractDistance; z <= _maxInteractDistance; z++)
            {
                GridPositionXZ offsetGridPosition = new GridPositionXZ(x, z, 0);  // Смещенная сеточная позиция. Где началом координат(0,0, 0-этаж) является сам юнит 
                GridPositionXZ testGridPosition = unitGridPosition + offsetGridPosition;  // Тестируемая Сеточная позиция

                if (!_unit.GetLevelGrid().IsValidGridPosition(testGridPosition)) // Проверим Является ли testGridPosition Допустимой Сеточной Позицией если нет то переходим к след циклу
                {
                    continue;
                }

                /*//Проверим тестируемую сеточную позицию на наличие двери
                DoorInteract door = _unit.GetLevelGrid().GetDoorAtGridPosition(testGridPosition);

                if (door == null)
                {
                    // В этой позиции сетки нет двери
                    continue;
                }*/
                // Применим интерфейс ВЗАИМОДЕЙСТВИЯ что бы мы могли взимодействовать не только с дверью
                IInteractable interactable = _unit.GetLevelGrid().GetInteractableAtGridPosition(testGridPosition);

                if (interactable == null)
                {
                    // В этой позиции сетки нет объекта взаимодействия
                    continue;
                }


                validGridPositionList.Add(testGridPosition);
            }
        }

        return validGridPositionList;
    }

    public override void TakeAction(GridPositionXZ gridPosition, Action onActionComplete) // Переопределим TakeAction (Применить Действие (Действовать). (Делегат onActionComplete - по завершении действия). в нашем случае делегату передаем функцию ClearBusy - очистить занятость
    {
        IInteractable interactable = _unit.GetLevelGrid().GetInteractableAtGridPosition(gridPosition); // Получим IInteractable(интерфейс взаимодействия) из переданной сеточной позиции // НАМ БЕЗ РАЗНИЦЫ КАКОЙ ОБЪЕКТ МЫ ПОЛУЧИМ (дверь, сфера, кнопка...) - лиш бы он реализовал этот интерфейс
        interactable.Interact(OnInteractComplete); //Произведем Взаимодействие с полученной IInteractable(интерфейс взаимодействия) и Передадим делгат - При завершении взаимодействия (этот делегат будет вызывать сама дверь)
        _targetGridPosition = gridPosition;
        ActionStart(onActionComplete); // Вызовим базовую функцию СТАРТ ДЕЙСТВИЯ // Вызываем этот метод в конце после всех настроек т.к. в этом методе есть EVENT и он должен запускаться после всех настроек
    }

    private void OnInteractComplete() //При завершении взаимодействия
    {

        OnAnyInteractActionComplete?.Invoke(this, EventArgs.Empty);
        ActionComplete(); //Действие завершено
                          //Что бы мы не смогли открывать и тутже закрывать дверь не дождавшись окончания действия - полного открытия или закрытия
                          //Будем вызывать данную функцию через делегат на самой ДВЕРИ когда на ней закончиться таймер

    }

    public override int GetMaxActionDistance()
    {
        return _maxInteractDistance;
    }

    public override string GetToolTip()
    {
        return "цена - " + GetActionPointCost() + "\n" +
                "дальность - " + GetMaxActionDistance() + "\n" +
                "можно открывать двери, и <color=#00ff00> ЗЕЛЕНЫЕ БОЧКИ</color>  ";
    }
}


